#pragma config(Sensor, S1,     HTSMUX,         sensorI2CCustom)
#pragma config(Sensor, S2,     compassSensor,  sensorI2CCustom)
#pragma config(Motor,  motorA,          rightMotor,    tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          clawMotor,     tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*Authors: Stephen Kinser
					 Kris Brown
					 Ashley Eden Cox

Project 2: Part 1
Due: 03/23/15
*/

// Include drivers for multiplexer and light sensor
#include "drivers/hitechnic-sensormux.h"
#include "drivers/lego-ultrasound.h"
#include "drivers/lego-light.h"
#include "drivers/lego-touch.h"
#include "drivers/hitechnic-compass.h"

// Define easy names for sensors connected to multiplexer
const tMUXSensor lightSensor = msensor_S1_4;	//Light sensor in smux port 4
const tMUXSensor  touchRight= msensor_S1_2;	//Touch right smux port 3
const tMUXSensor  touchLeft = msensor_S1_3; //Touch left smux port 2
const tMUXSensor ultrasonicSensor = msensor_S1_1; // Ultrasonic smux port 1



//declaring motor speeds
int MOTOR_MAX = 50;
int MOTOR_MIN = -50;
bool wall= false;
bool egg= false;
int compassReading;
int nestValue;
int floorValue;



/*BASIC FUNCTIONS-------------------------------------------------------------------- */
//this moves the robot forwards
void Forward( int length)
{
	nSyncedMotors=synchAB;
	while(nMotorEncoder[leftMotor]< length){ //set to slaves later
	motor[rightMotor] = MOTOR_MAX;
	motor[leftMotor] = MOTOR_MAX;
}
}
void Forward( )
{
		nSyncedMotors=synchAB;
	motor[rightMotor] = MOTOR_MAX;
	//motor[leftMotor] = MOTOR_MAX;
}
//this moves the robot to the left
void Left( int length, int turnRadians)
{
	nSyncedMotors=synchBA;
	nSyncedTurnRatio= turnRadians;
	//	nxtDisplayCenteredTextLine(0, "%d",(nMotorEncoder[leftMotor]));
	//wait10Msec(10000);
	while(nMotorEncoder[leftMotor]<length){
	//motor[rightMotor] = MOTOR_MIN;
	motor[leftMotor] = MOTOR_MAX;
}
}
//this moves the robot right
void Right( int length, int turnRadians)
{
	nSyncedMotors=synchAB;
	nSyncedTurnRatio= turnRadians;
	while(nMotorEncoder[leftMotor]<length){
	motor[rightMotor] = MOTOR_MAX;
	//motor[leftMotor] = MOTOR_MIN;
}
}
//this moves the robot backwards
void Backwards( int length)
{
	nSyncedMotors=synchAB;
	while(nMotorEncoder[leftMotor]<length){
	motor[rightMotor] = MOTOR_MIN;
	//motor[leftMotor] = MOTOR_MIN;
	}
}
//this funciton halts the robot
void Halt()
{
	motor[rightMotor] = 0;
	motor[leftMotor] = 0;
}
void raiseArm(){
	while(nMotorEncoder[clawMotor] <500){ //setting it to arbitrary value until can make an angle based assumption
	motor[clawMotor]= MOTOR_MAX;
}
}
void lowerArm(){
	while(nMotorEncoder[clawMotor] <500){ //setting it to arbitrary value until can make an angle based assumption
	motor[clawMotor]= MOTOR_MIN;
}
}
/* ENABLE AND DISABLE FUNCTIONS---------------------------------------------------------
void enable(int pid)
{
	process_enable[pid] = process_priority[pid];
}

void disable(int pid)
{
	process_enable[pid] = 0;
}*/
/*-----------maybe a helper function like periodic turn to help the robot wander more effectively? */
/*void periodic_turn(int pid)
{
	while(true)
	{
		if( time100)
		{
			enable(pid);
			Right(pid);
			//msleep(500L); Use halt instead?
			Halt(pid);
			disable(pid);
			//msleep();
			Halt(pid);
		}
	}
}*/

/* THESE ARE THE MAIN TASKS AS DESCRIBED ON THE PROJECT DESCRIPTION---------------------- */
//this makes the robot wander
task Wander()
{
	//add in a loop for timer to make the robot stop program after a certain amount of time (nothing is found)
	ClearTimer(T1);
	//time10[T1] < 120000
	while(time10[T1] < 120000)//2 minutes
	{
		//nMotorEncoder[leftMotor]=0; //not sure if need to reset periodically
		//nMotorEncoder[rightMotor]=0;
		int decision =random(100)%3;//%3
		switch(decision){ //goes in one of the 8 directions
			case 0:
				Forward(random(500)+250);
			break;
			case 1:
				Left(random(500) + 250, 45); //pass two arguments, the length of distance traveled and the turn radius
			break;
			case 2:
				Right(random(500) + 250, 45);
			break;
	/*		case 3:
				Backwards(random(500) + 250);
			break;
			case 4:
				Forward(random(500) + 250);
				Left(random(500) + 250);
			break;
			case 5:
				Forward(random(500) + 250);
				Right(random(500) + 250);
			break;
			case 6:
				Backwards(random(500) + 250);
				Left(random(500) + 250);
			break;
			case 7:
				Backwards(random(500) + 250);
				Right(random(500) + 250);
				break;
*/
			default:
			nxtDisplayStringAt(0, 31, "error with random number generator");
			wait10Msec(1000);
			break;

	}
	}

	//enable(pid);
	//Forward();
}

//this makes the robot move towards the egg
//useing the ULTRASONIC_PORT to close the distance from robot to egg
task PushEggTowardsNest()
{
	StopTask(MoveTowardsEgg); //
		while((compassReading + 180) %360 == SensorValue(compassSensor)){// hopefully do a 180 degree turn
			motor[rightMotor] = MOTOR_MAX;
			}

}
task MoveTowardsEgg()
{
	int distance = 10; // need to test value
	while(USreadDist(ultrasonicSensor) > distance ){
		Forward();
		//might add a detect egg function in here
	}
	lowerArm();
	egg=true;// assume it was sucessful for now
	StartTask(PushEggTowardsNest);
}
/*this stops the robot when it hits the egg
we will be using values from the ULTRASONIC_PORT
when readings are negative or not in range, that means we have the egg
*/
//task StopAtEgg()
//{

//}

//this will make the robot push the egg towards the nest
//need compass values from COMPASS_PORT to find way back to nest

//this will makes the robot push the egg into the nest(blue zone)
//will be using the LIGHT_SENSOR to detect the colors of the nest and line to it
task detectOutOfBounds()
{

	if(SensorValue(lightSensor)== nestValue){
		if( egg ==false){				//might logically shortcut it later
		nSyncedMotors=synchAB;
		nSyncedTurnRatio=  90; // try to do a full 180 turn at a sharp angle to reduce time
		while((compassReading + 180) %360 == SensorValue(compassSensor)){
			motor[rightMotor] = MOTOR_MAX;
			}
		}
		else{ // we have the egg
			Forward(300);
			raiseArm();
			egg= false;
			Right(100, 45);

		}
	}
}

//this will detect a wall
//when LEFT_TOUCH_SENSOR or RIGHT_TOUCH_SENSOR is pressed?
//how do we tell the wall is different from the eggs?
task DetectWall()
{
	while( !TSreadState(touchLeft) && !TSreadState(touchRight)); //while this isn't detected, do nothing


		wall= true;
		Halt();//when detected stop
		//StopTask(Wander);
		wait10Msec(20);// wait
		Backwards(50); //then backwards
		Right(50, 45);// turn to get out of the way
		//StartTask(Wander);
}

//this is where all the functions are called
task main()
{

	//initialize because junk values are a thing
	nMotorEncoder[leftMotor]=0;
	nMotorEncoder[rightMotor]=0;
	nMotorEncoder[clawMotor]=0;
	//raiseArm();// make sure it starts out as "ready to use"
/*************************************************************
									Get the Nest Value
**************************************************************/
	 while (nNxtButtonPressed != 3) {
	 // The enter button has been pressed, switch
    // to the other mode
   // nxtDisplayClearTextLine(0);
    nxtDisplayClearTextLine(1);
    nestValue = LSvalRaw(lightSensor);// could use the "Norm value" too
    nxtDisplayTextLine(0, "Lego");
    nxtDisplayTextLine(1, "Nest Value: %4d", nestValue);
     wait1Msec(25);
  }
	wait1Msec(200);

/*************************************************************
									Get the Floor Value
**************************************************************/
  while (nNxtButtonPressed != 3) {
	 // The enter button has been pressed, switch
    // to the other mode
    //nxtDisplayClearTextLine(0);
    nxtDisplayClearTextLine(1);
    floorValue = LSvalRaw(lightSensor);// could use the "Norm value" too
    nxtDisplayTextLine(0, "Lego");
    nxtDisplayTextLine(1, "Floor Value: %4d", floorValue);
     wait1Msec(25);
  }
	wait1Msec(200);

/*************************************************************
									Get the Compass Value
**************************************************************/
	 while (nNxtButtonPressed != 3) {
	 // The enter button has been pressed, switch
    // to the other mode
    //nxtDisplayClearTextLine(0);
    nxtDisplayClearTextLine(1);
    compassReading = LSvalRaw(compassSensor);// could use the "Norm value" too
    nxtDisplayTextLine(0, "Lego");
    nxtDisplayTextLine(1, "Floor Value: %4d", compassReading);
     wait1Msec(25);
  }
  wait1Msec(200);

  /*************************************************************************
  								Actually Start Task Here
  *************************************************************************/
	//StartTask(detectOutOfBounds);
	StartTask(DetectWall);
	StartTask(MoveTowardsEgg);
	StartTask(Wander);

	while(LSvalRaw(lightSensor) != floorValue); // do not start the task until we have gotten onto the floor
		StartTask(detectOutOfBounds);

	while(true); // set to some logical expression later, preferrably a "We have completed the task" or I have pressed a button
		// this may be difficult without prior knowledge of the course
	//StopAllTasks();
 /*************************************
 			Light Sensor Test
 ***************************************
int raw = 0;
  int nrm = 0;
  bool active = true;

  // Turn the light on
  LSsetActive(lightSensor);
  wait1Msec(2000);
  //LSsetInactive(lightSensor);


  nNxtButtonTask  = -1;

  nxtDisplayCenteredTextLine(0, "Lego");
  nxtDisplayCenteredBigTextLine(1, "Sonar");
  nxtDisplayCenteredTextLine(3, "SMUX Test");
  nxtDisplayCenteredTextLine(5, "Connect SMUX to");
  nxtDisplayCenteredTextLine(6, "S1 and sensor to");
  nxtDisplayCenteredTextLine(7, "SMUX Port 1");
  wait1Msec(2000);

  nxtDisplayClearTextLine(7);
  nxtDisplayTextLine(5, "Press [enter]");
  nxtDisplayTextLine(6, "to toggle light");
  wait1Msec(2000);

  while (nNxtButtonPressed != 3) {
    // The enter button has been pressed, switch
    // to the other mode
    nxtDisplayClearTextLine(5);
    nxtDisplayClearTextLine(6);
    raw = LSvalRaw(lightSenso);
    nrm = LSvalNorm(lightSensor);
    nxtDisplayTextLine(5, "Raw:  %4d", raw);
    nxtDisplayTextLine(6, "Norm: %4d", nrm);
    wait1Msec(2000);
    }
    */

 /*************************************
 			Ultrason Sensor Test
 ***************************************
    int dist = 0;

  nxtDisplayCenteredTextLine(0, "Lego");
  nxtDisplayCenteredBigTextLine(1, "US");
  nxtDisplayCenteredTextLine(3, "SMUX Test");
  nxtDisplayCenteredTextLine(5, "Connect SMUX to");
  nxtDisplayCenteredTextLine(6, "S1 and US sensor");
  nxtDisplayCenteredTextLine(7, "to SMUX Port 1");
  wait1Msec(2000);

  eraseDisplay();
  nxtDisplayTextLine(0, "Lego US Sensor");

  while(true) {
    // Read the current distance detected.
    dist = USreadDist(ultrasonicSensor);

    // display the info from the sensor
    nxtDisplayTextLine(3, "Dist:  %3d cm", dist);
    wait10Msec(50);
  }
  */

  /*************************************
 			Compass Sensor Test
 ***************************************


  int _target = 0;

  nxtDisplayCenteredTextLine(0, "HiTechnic");
  nxtDisplayCenteredBigTextLine(1, "Compass");
  nxtDisplayCenteredTextLine(3, "Test 1");
  nxtDisplayTextLine(5, "Press enter");
  nxtDisplayTextLine(6, "to set target");

  wait1Msec(2000);
  eraseDisplay();
  time1[T1] = 0;
  while(true) {
    // Reset the target no more than once a second
    // This also helps with debouncing the [enter] button.
    if (time1[T1] > 1000) {
      eraseDisplay();
      nxtDisplayTextLine(1, "Changing");
      nxtDisplayTextLine(2, "target");
      wait1Msec(500);
      // Set the current heading as the value for the offset to be used as the
      // new zero-point for the relative heading returned by
      // HTMCreadRelativeHeading()
      _target = HTMCsetTarget(compassSensor);
      PlaySound(soundBlip);
      while(bSoundActive) EndTimeSlice();
      time1[T1] = 0;
    }

    // Get the true heading and relative heading from the sensor and
    // display them on the screen.
    while(nNxtButtonPressed != kEnterButton) {
      eraseDisplay();
      nxtDisplayTextLine(1, "Reading");
      nxtDisplayTextLine(2, "Target: %4d", _target);
      nxtDisplayTextLine(4, "Abs:   %4d", HTMCreadHeading(compassSensor));
      nxtDisplayTextLine(5, "Rel:   %4d", HTMCreadRelativeHeading(compassSensor));
      nxtDisplayTextLine(6, "Press enter");
      nxtDisplayTextLine(7, "to set target");
      wait1Msec(100);
    }
  }
  */

  }
