 #pragma config(Sensor, S1,     HTSMUX,         sensorI2CCustom)
#pragma config(Sensor, S2,     compassSensor,  sensorI2CCustom)
#pragma config(Sensor, S4,     sonarSensor,         sensorSONAR)
#pragma config(Motor,  motorB,          rightMotor,    tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorA,          leftMotor,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          clawMotor,     tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*Authors: Stephen Kinser
					 Kris Brown
					 Ashley Eden Cox

Project 3: Part 1
Due: 04/29/15
*/

// Include drivers for multiplexer and light sensor

#include "drivers/lego-ultrasound.h"
#include "motion.h"

#define ROW 8
#define COL 16

#define NORTH 1
#define SOUTH 2
#define WEST 3
#define EAST 4

//world 1
//int worldArray[8][16] =
//						{{2,0,0,0,0,0,0,0,1,0,0,0,1,1,1,1},
//							{0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0},
//							{0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0},
//							{0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0},
//							{0,0,0,1,1,1,1,0,0,0,0,0,1,0,0,0},
//							{0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0},
//							{0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0},
//							{0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0}};
							//world 2
							int worldArray[8][16] =
							{{2,0,0,0,0,0,0,1,1,1,1,0,0,1,0,0},
							{0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0},
							{0,0,0,0,0,0,1,1,1,1,0,0,0,1,0,0},
							{0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0},
							{0,0,0,1,1,1,1,0,0,1,0,0,0,0,0,0},
							{0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0},
							{0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0}};
void printMap();
void WavefrontSearch( int goal_x, int goal_y);
task main()
{

	//initialize because junk values are a thing
	nMotorEncoder[leftMotor]=0;
	nMotorEncoder[rightMotor]=0;

	int dist = 565; // Approximately one square
	int turnDist = 221;



	int x = 0;
	int y = 0;
	int distance = 0;
	int currentVal = worldArray[x][y];
	int finalx= 2;
	int finaly= 15;
	int currFace = SOUTH;
	WavefrontSearch(finalx,finaly);
	//printMap();
	//while(1);
	 while(!((x ==finalx )&& (y == finaly)) )
 {
			 // //setting currentVal to the goal spot

				//if goalx goaly+1 != 1 && > curr val
			  // move right, chg prev 99, inc pathcount
				nxtDisplayTextLine(1,"X :%d, Y: %d", x, y);
				nxtDisplayTextLine(2,"Direction %d", currFace);
				int north = (y == 0) ? 0 : worldArray[x][y - 1];
				int south = (y == COL - 1) ? 0 : worldArray[x][y + 1];
				int east = (x == ROW - 1) ? 0 : worldArray[x+1][y];
				int west = (x == 0) ? 0 : worldArray[x-1][y];
				nxtDisplayTextLine(3,"N :%d, S :%d", north, south );
				nxtDisplayTextLine(4,"E :%d W: %d",east, west );
				nxtDisplayTextLine(5,"Current: %d",currentVal );
			if ( y < COL && (worldArray[x][y + 1]== 98 )) //this direction is SOUTH
			  {
			  	worldArray[x][y]=0;
				  y = (y + 1); //updating y
				   if(currFace == NORTH)
				  {
					//rotate right 2 times
				  Right(turnDist,-100);
				  Right(turnDist,-100);
				  wait10Msec(100);
					  currFace = SOUTH;
				  }
				  else if(currFace == EAST)
				  {
					//rotate right 1 times
				  Right(turnDist,-100);
				  wait10Msec(100);
					  currFace = SOUTH;
				  }
				  else if(currFace == WEST)
				  {
					//rotate right 3 times
				 	 Left(turnDist,-100);
				 	 wait10Msec(100);
					  currFace = SOUTH;
				  }
				 //GO STRAIGHT
				 Forward(dist);
				 wait1Msec(1000);
				 worldArray[x][y] = 98;
				  distance ++;
			  }
			    //if goalx+1 goaly != 1 && > curr val
			  // move down, chg prev 99, inc pathcount
			  else if ( x < ROW && (worldArray[x + 1][y] == 98 ) )// this direction is EAST
			  {
			  	worldArray[x][y]=0;
			  	x++;
				   if(currFace == NORTH)
				  {
					//rotate right 1 times
				  Right(turnDist,-100);
				  wait10Msec(100);
					  currFace = EAST;
				  }
				  else if(currFace == WEST)
				  {
					//rotate right 2 times
				  	Right(turnDist,-100);
				  	Right(turnDist,-100);
				 	 wait10Msec(100);
					  currFace = EAST;
				  }
				  else if(currFace == SOUTH)
				  {
					//rotate right 3 times
				  Left(turnDist,-100);
				  wait10Msec(100);
					  currFace = EAST;
				  }

				  //GO STRAIGHT
				   Forward(dist);
				   wait1Msec(1000);
				  //worldArray[x][y] = 98;
				  distance ++;
			  }

				//if [goalx -1][ y] != 1 && > current val && if the row is not 0 (to keep in bounds)
			  // move up, change prev to 99, increment pathcount
			  else if( x > 0 && (worldArray[x - 1][y]==98 ))// this direction is WEST
			  {
					worldArray[x][y]=0;
				  x = (x - 1);
				  if(currFace == NORTH)
				  {
					//rotate right 3 times
				  Left(turnDist,-100);
				  wait10Msec(100);
					  currFace = WEST;
				  }
				  else if(currFace == EAST)
				  {
					//rotate right 2 times
				    Right(turnDist,-100);
				  	Right(turnDist,-100);
				  	wait10Msec(100);
					  currFace = WEST;
				  }
				  else if(currFace == SOUTH)
				  {
					//rotate right 1 times
				  Right(turnDist,-100);
				  	wait10Msec(100);
					  currFace = WEST;
				  }

				  //GO STRAIGHT
				  	Forward(dist);
				  	wait1Msec(1000);
				 distance ++;


			  }
			  //if [goalx][goaly-1] != 1 && > curr val
			  // move left, change prev val to 99, increment pathcount
			  else if ( y > 0 && (worldArray[x][y - 1]==98)) // this direction is NORTH
			  {
				 worldArray[x][y]=0;
				  y = (y - 1);
				   if(currFace == WEST)
				  {
					//rotate right 1 times
				 	 Right(turnDist,-100);
				   	wait10Msec(100);
					  currFace = NORTH;
				  }
				  else if(currFace == EAST)
				  {
					//rotate right 3 times
				  	  Left(turnDist,-100);
				  wait10Msec(100);
					  currFace = NORTH;
				  }
				  else if(currFace == SOUTH)
				  {
					//rotate right 2 times
				   Right(turnDist,-100);
				   	wait10Msec(100);
					  currFace = NORTH;
				  }
				  //GO STRAIGHT
				   Forward(dist);
				   wait1Msec(1000);
				  //worldArray[x][y] = 98;
				  distance ++;
			  }

 			wait1Msec(1000);

	}

	 // set to some logical expression later, preferrably a "We have completed the task" or I have pressed a button
		// this may be difficult without prior knowledge of the course
}	//StopAllTasks();


void WavefrontSearch(  int goal_x, int goal_y)
{
 //int goal_x, goal_y, goal;
  bool foundWave = true;
  int currentWave = 2; //Looking for goal first

int gx2=goal_x;
int gy2=goal_y;
	nxtDisplayCenteredTextLine(1, "Wave Front Start");

  int goal = 98;





  while(foundWave == true)
  {
    foundWave = false;
    for(int y=0; y < COL; y++)
    {
      for(int x=0; x < ROW; x++)
      {
        if(worldArray[x][y] == currentWave)
        {
          foundWave = true;
          goal_x = x;
          goal_y = y;

		  if(goal_x > 0){ //This code checks the worldArray bounds heading WEST
            if(worldArray[goal_x-1][goal_y] == 0) { //This code checks the WEST direction
              worldArray[goal_x-1][goal_y] = currentWave + 1;}}

          if(goal_x < (ROW - 1)) {//This code checks the worldArray bounds heading EAST
            if(worldArray[goal_x+1][goal_y] == 0){//This code checks the EAST direction
              worldArray[goal_x+1][goal_y] = currentWave + 1;}}

          if(goal_y > 0){//This code checks the worldArray bounds heading SOUTH
            if(worldArray[goal_x][goal_y-1] == 0){ //This code checks the SOUTH direction
              worldArray[goal_x][goal_y-1] = currentWave + 1;}}

          if(goal_y < (COL - 1)){//This code checks the worldArray bounds heading NORTH
            if(worldArray[goal_x][goal_y+1] == 0){ //This code checks the NORTH direction
              worldArray[goal_x][goal_y+1] = currentWave + 1;}}
        }//endif
      }//endfor
    }//endif
    currentWave++;
  }//endwhile


	int x= gx2;
  int y= gy2;
  int currentVal = worldArray[x][y];
  worldArray[x][y] = 98; //set goal
  int distance =0;

  while(currentVal != 2 )
		 {
			 //setting currentVal to the goal spot


			  //if [goalx -1][ y] != 1 && < current val && if the row is not 0 (to keep in bounds)
			  // move up, change prev to 99, increment pathcount
			  if(x != 0 && (worldArray[x - 1][y] < currentVal) && worldArray[x -1][y] != 1 ){
				  currentVal = worldArray[x - 1][y];
				  x = (x - 1);
				  worldArray[x][y] = 98;

				 distance ++;


			  }
			  //if [goalx][goaly-1] != 1 && < curr val
			  // move left, change prev val to 99, increment pathcount
			  else if (  y != 0 && (worldArray[x][y - 1] < currentVal) && worldArray[x][y - 1] != 1 ){
				  currentVal = worldArray[x][y - 1];
				  y = (y - 1);
				  worldArray[x][y] = 98;

				  distance ++;
			  }
			    //if goalx+1 goaly != 1 && < curr val
			  // move down, chg prev 99, inc pathcount

			  else if ( x < (ROW-1) &&(worldArray[x + 1][y] < currentVal) && worldArray[x + 1][y] != 1  ){
			  currentVal = worldArray[x + 1][y];
			  x = (x + 1);
			  worldArray[x][y] = 98;

			  distance ++;
		  }
		  //if goalx goaly+1 != 1 && < curr val
		  // move right, chg prev 99, inc pathcount
		  else if ( y < (COL-1) &&(worldArray[x][y + 1] < currentVal) && worldArray[x][y + 1] != 1  ){
			  currentVal = worldArray[x][y + 1];
			  y = (y + 1);
			  worldArray[x][y] = 98;

			  distance ++;
		  }
}
  wait10Msec(10);
  nxtDisplayClearTextLine(1);
	nxtDisplayCenteredTextLine(1, "Wave Front End");

}
void printMap(){
	string src= " ";
	/*= (char) ('0' + 1);
	src = src + " ";
	src = src + (char) ('0' + 2);*/
	nxtDisplayTextLine(0,"THE MAP");
	for( int i = 0; i < ROW; i++){
			for(int j = 11; j < COL; j++){
				if( worldArray[i][j] -10 < 0){
				src = src + (char ) ('0' + worldArray[i][j]);
				src = src + "  ";
			}
			else{
				src = src + (char ) ('0' + worldArray[i][j]/10);
				src = src + (char ) ('0' + worldArray[i][j]%10);
				src = src + " ";
			}

		}
		nxtDisplayTextLine(i+1,"%s", src);
		src= " ";
	}




}
